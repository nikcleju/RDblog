<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-01-16">
<meta name="description" content="A review of papers showing how to use VAEs for unsupervised anomaly detection">

<title>My Notes - Unsupervised Anomaly Detection with Variational Autoencoders</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">My Notes</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Unsupervised Anomaly Detection with Variational Autoencoders</h1>
                  <div>
        <div class="description">
          A review of papers showing how to use VAEs for unsupervised anomaly detection
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">paper</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 16, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#review-papers" id="toc-review-papers" class="nav-link active" data-scroll-target="#review-papers">Review papers</a>
  <ul class="collapse">
  <li><a href="#an2015" id="toc-an2015" class="nav-link" data-scroll-target="#an2015">An2015</a></li>
  <li><a href="#wievel2019" id="toc-wievel2019" class="nav-link" data-scroll-target="#wievel2019">Wievel2019</a></li>
  <li><a href="#yao2023" id="toc-yao2023" class="nav-link" data-scroll-target="#yao2023">Yao2023</a></li>
  <li><a href="#lappas2021" id="toc-lappas2021" class="nav-link" data-scroll-target="#lappas2021">Lappas2021</a></li>
  <li><a href="#choi2023" id="toc-choi2023" class="nav-link" data-scroll-target="#choi2023">Choi2023</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="VAEAnomalyDetection.tex"><i class="bi bi-file"></i>LaTeX</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="review-papers" class="level2">
<h2 class="anchored" data-anchor-id="review-papers">Review papers</h2>
<section id="an2015" class="level3">
<h3 class="anchored" data-anchor-id="an2015">An2015</h3>
<p><strong>Variational Autoencoder based Anomaly Detection using Reconstruction Probability</strong></p>
<blockquote class="blockquote">
<p>InProceedings (An2015)<br>
An, J. &amp; Cho, S.<br>
Variational Autoencoder based Anomaly Detection using Reconstruction Probability<br>
2015</p>
</blockquote>
<p><img src="img/2023-01-16-17-17-52.png" class="img-fluid"></p>
<p>The algorithm:</p>
<ul>
<li><p>VAEs learn a distribution of the inputs</p></li>
<li><p>The latent distribution <span class="math inline">\(p(z)\)</span> acts as a prior (in Bayesian terms), and is the multivariate standard normal and isotropic (i.e.&nbsp;separable, covariance matrix is diagonal)</p></li>
<li><p><span class="math inline">\(f(x)\)</span> is the encoder function</p></li>
<li><p><span class="math inline">\(g(z)\)</span> is the decoder function</p></li>
<li><p>The decoder function <span class="math inline">\(g(z)\)</span> maps the distribution of the latent variable <span class="math inline">\(z\)</span> into an output distribution <span class="math inline">\(p(x|z)\)</span> which should resemble the original distribution of <span class="math inline">\(x\)</span></p></li>
<li><p>During reconstruction, when we sample a single latent variable <span class="math inline">\(z\)</span>, we reconstruct a single vector <span class="math inline">\(\hat{x}\)</span>, so we have a single sample of the output distribution <span class="math inline">\(p(x|z)\)</span></p></li>
<li><p>Idea for using Reconstruction Probability as an anomaly measure:</p>
<ul>
<li><p>sample multiple latent variables <span class="math inline">\(z^k\)</span>, and for each of them reconstruct the vector <span class="math inline">\(\hat{x}^k\)</span></p></li>
<li><p>use all the vectors <span class="math inline">\(\hat{x}^k\)</span> to estimate the probability <span class="math inline">\(p(x|z)\)</span>, and then compute the likelihood that the original input <span class="math inline">\(x\)</span> comes from this distribution</p></li>
<li><p>assuming <span class="math inline">\(p(x|z)\)</span> is a an isotropic normal distribution, we just compute the mean <span class="math inline">\(\mu = E \lbrace \hat{x} \rbrace\)</span> and covariance matrix <span class="math inline">\(\Sigma\)</span> (diagonal, so basically we compute the variance <span class="math inline">\(\sigma_i^2\)</span> per entry of the vector)</p></li>
<li><p>the log-likelihood that the original <span class="math inline">\(x\)</span> is generated by this distribution amounts to a weighted <span class="math inline">\(\ell_2\)</span> norm:</p>
<p><span class="math display">\[L(x) = \sum_i \frac{(x_i - \mu_i)^2}{\sigma_i^2}\]</span></p></li>
<li><p>we use this as an anomaly score: small value = more anomaly, large value = more normal</p></li>
<li><p>small value =&gt; anomaly, because <span class="math inline">\(x\)</span> does not fit the output probability <span class="math inline">\(p(x|z)\)</span></p></li>
</ul></li>
<li><p>Better than normal AE, because the variances are taken into account</p></li>
<li><p>Perhaps the variances <span class="math inline">\(\sigma_i^2\)</span> can be used as indicators for feature selection?</p>
<ul>
<li>or are they just similar to the clones values based on the input variances</li>
</ul></li>
</ul>
</section>
<section id="wievel2019" class="level3">
<h3 class="anchored" data-anchor-id="wievel2019">Wievel2019</h3>
<p><strong>Continual Learning for Anomaly Detection with Variational Autoencoder</strong></p>
<blockquote class="blockquote">
<p>InProceedings (Wiewel2019)<br>
Wiewel, F. &amp; Yang, B.<br>
Continual Learning for Anomaly Detection with Variational Autoencoder<br>
ICASSP 2019 - 2019 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), 2019, 3837-3841</p>
</blockquote>
<ul>
<li><p>Use the full loss function as anomaly score, which includes the reconstruction error <strong>and</strong> the KL distance between the distribution of <span class="math inline">\(z\)</span> and the standard normal prior <span class="math inline">\(p(z)\)</span></p>
<ul>
<li><blockquote class="blockquote">
<p>the so called evidence lower bound (ELBO): <img src="img/2023-01-16-17-50-43.png" class="img-fluid"></p>
</blockquote></li>
<li><blockquote class="blockquote">
<p>While [4, 5, 6, 7] use the reconstruction probability E q φ (z|x i ) [ln p θ (x i |z)] as the anomaly score, we use the ELBO as the anomaly score because it gives slightly better results in our experiments.</p>
</blockquote></li>
</ul></li>
<li><p>The “reconstruction probability” used in An2015 is just the first part of the loss function (ELBO), why not use the full loss, since this is what the model was trained to minimize</p></li>
</ul>
</section>
<section id="yao2023" class="level3">
<h3 class="anchored" data-anchor-id="yao2023">Yao2023</h3>
<blockquote class="blockquote">
<p>Article (Yao2023)<br>
Yao, Y.; Ma, J. &amp; Ye, Y.<br>
Regularizing autoencoders with wavelet transform for sequence anomaly detection<br>
Pattern Recognition, 2023, 134, 109084</p>
</blockquote>
<p><img src="img/2023-02-27-09-36-02.png" class="img-fluid"></p>
<p><img src="img/2023-02-27-09-36-27.png" class="img-fluid"></p>
<ul>
<li>Use a custom loss function which includes filtering with DWT</li>
<li>Learn the regularization parameter <span class="math inline">\(\lambda\)</span> which balances between AE loss and fixed DWT error</li>
<li>Only for training. In production, only AE used, as normal.</li>
<li>Empirical, non-reliable, DWT features</li>
<li>Idea: Learn <strong>less</strong> the vectors which are less modified by DWT
<ul>
<li>when second term is close to 0 (i.e.&nbsp;input vector unchanged by DWT filtering), <span class="math inline">\(\lambda\)</span> becomes close to 1, which reduces the influence of the AE loss, so the AE will learn <strong>less</strong> about these vectors</li>
<li>so these vectors will be reconstructed more poorly, so more likely to be considered outliers</li>
<li>a way to make some inputs more likely to be declared outliers: vectors untouched by DWT filtering are learned less, so more likely to be outliers</li>
</ul></li>
<li>Afterthoughts:
<ul>
<li>What if we <strong>multiply</strong> somehow two learnables? i.e.&nbsp;<span class="math inline">\(\lambda \cdot \| AE loss \|\)</span>, or <span class="math inline">\(AE1 loss \cdot AE2 loss\)</span>. Which learns faster?</li>
<li>If one NN learns first (e.g.&nbsp;<span class="math inline">\(\lambda\)</span>), it will reduce the incentive for the other one to learn.</li>
<li>What if <span class="math inline">\(\lambda\)</span> adapts much slower than the AE? <span class="math display">\[(1 - \lambda) AE_{loss}  + \lambda Const\]</span></li>
<li>AE loss drops first, then lambda will learn much later if the input is an outlier or not:
<ul>
<li>if AE loss is small, <span class="math inline">\(\lambda\)</span> will be close to 1</li>
<li>if AE loss is large, <span class="math inline">\(\lambda\)</span> will be close to 0</li>
<li>just an indirect reflection of AE loss / C ?</li>
</ul></li>
<li>Two NNs in competition. Does it matter which one learns first?</li>
<li>Outlier detection based on speed of learning?</li>
</ul></li>
</ul>
</section>
<section id="lappas2021" class="level3">
<h3 class="anchored" data-anchor-id="lappas2021">Lappas2021</h3>
<blockquote class="blockquote">
<p>InProceedings (Lappas2021)<br>
Lappas, D.; Argyriou, V. &amp; Makris, D.<br>
Fourier Transformation Autoencoders for Anomaly Detection<br>
ICASSP 2021 - 2021 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP), 2021, 1475-1479</p>
</blockquote>
<p><img src="img/2023-02-27-10-00-46.png" class="img-fluid"></p>
<ul>
<li>Augment input vector with Fourier transform, real and imaginary parts</li>
<li>Learn three coders, for each part</li>
<li>Concatenate the latent variables</li>
<li>A single decoder, which produces the real and imaginary parts</li>
<li>Architecture:
<ul>
<li>3N =&gt; 3L =&gt; 2N</li>
</ul></li>
<li>Y’ to X’ means what?? “Another mapping”</li>
</ul>
</section>
<section id="choi2023" class="level3">
<h3 class="anchored" data-anchor-id="choi2023">Choi2023</h3>
<blockquote class="blockquote">
<p>TechReport (Choi2023)<br>
Choi, J.; Park, J.; Japesh, A. &amp; Adarsh<br>
A Subspace Projection Approach to Autoencoder-based Anomaly Detection<br>
arXiv, arXiv, 2023</p>
</blockquote>
<p><img src="img/2023-02-27-10-13-03.png" class="img-fluid"></p>
<ul>
<li>Information theoretic interpretation (MIMO), but not sure if useful at all</li>
<li>Practically: evaluate reconstruction error only on the subspace of the least significant eigenvectors of the error vectors
<ul>
<li>If error is large =&gt; outlier, if small, normal</li>
</ul></li>
<li><strong>Just another example of weighted <span class="math inline">\(\ell_2\)</span> norm</strong>
<ul>
<li>here is in the space of the eigenvectors, inversely prop to variance (eigenvalues) (here just with 0, 1 binary selection)</li>
<li>here it is the covariance matrix of all errors, since for AE we have a 1-to-1 input to output (single output vector)</li>
<li>for VAE, we have the same idea, but the covariance matrix is per input vector, since we have 1-to-many (one input, multiple outputs) (see An2015)</li>
</ul></li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>